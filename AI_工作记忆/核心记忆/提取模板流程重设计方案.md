# 提取模板功能完整重设计方案

## 📋 **当前问题分析**

### 现有流程的问题
1. **重复询问**：用户需要在多个地方重复选择相似的选项
2. **流程混乱**：缺乏清晰的状态检测和条件化处理
3. **用户困惑**：选项含义不明确，缺少状态反馈
4. **逻辑冲突**：某些选择组合会导致不合理的结果

### 用户反馈的核心问题
- "以英文 DefInjected 为基础"功能仍然错误
- 缺少清晰的环境状态检测
- 选项太多且重复，用户体验差
- 缺少冲突处理和备份机制

## 🎯 **用户建议的完整解决方案**

### **第一步：全面状态检测**
```
🔍 正在检测模组和输出目录状态...
[████████████████████████████████] 100%

📊 检测结果摘要：
┌─────────────────────────────────────────┐
│ 📂 模组翻译资源检测：                    │
│    英文 DefInjected 目录: ✅ 已找到      │
│    └── 路径: mod/Languages/English/DefInjected │
│    └── 包含文件: 25 个翻译文件           │
│                                         │
│    英文 Keyed 目录: ✅ 已找到           │
│    └── 路径: mod/Languages/English/Keyed │
│    └── 包含文件: 8 个翻译文件            │
│                                         │
│ 📁 输出目录状态检测：                    │
│    输出 DefInjected 目录: ❌ 不存在      │
│    输出 Keyed 目录: ❌ 不存在           │
└─────────────────────────────────────────┘
```

### **第二步：数据来源选择**（条件化）

#### 情况A：检测到英文 DefInjected 目录
```
✅ 检测到英文 DefInjected 目录，请选择数据来源：

💡 选择建议：
   选项1: 适合模组翻译更新，速度快，基于现有翻译结构
   选项2: 适合首次翻译或完整检查，速度慢，但内容完整

1. 🔄 使用 DefInjected 目录提取翻译（推荐）
   └── 基于现有翻译结构，快速生成模板
   └── 预计提取: ~2198 条翻译内容
   
2. 🔍 扫描 Defs 文件重新提取（完整扫描）
   └── 从源头扫描所有定义，确保无遗漏
   └── 预计提取: ~2500+ 条翻译内容
   
3. 🚫 返回主菜单

请输入选项编号（1/2/3，回车默认1）：
```

#### 情况B：未检测到英文 DefInjected 目录
```
❌ 未检测到英文 DefInjected 目录

📋 自动处理方案：
   └── 将自动扫描 Defs 文件提取所有翻译内容
   └── 预计提取: ~2500+ 条翻译内容
   └── 按定义类型自动组织文件结构

🚀 按回车继续，或输入 'b' 返回主菜单：
```

### **第三步：输出冲突处理**（条件化）

#### 情况A：输出目录已有翻译文件
```
⚠️ 检测到输出目录中已有翻译文件：
   📁 DefInjected: 15 个文件 (上次修改: 2025-06-27 10:30)
   📁 Keyed: 6 个文件 (上次修改: 2025-06-27 10:30)

请选择处理方式：

1. 🔄 智能合并（推荐）
   └── 保留已有翻译，仅添加新发现的条目
   └── 生成合并报告，显示新增/更新内容
   
2. 📋 备份后重建
   └── 备份到: backup_20250627_143000/
   └── 然后重新生成所有翻译文件
   
3. ⚠️ 直接覆盖（危险）
   └── 会永久丢失所有已有翻译内容
   
4. 📊 查看详情后决定
   └── 显示现有翻译文件的详细信息
   
5. 🚫 返回主菜单

请输入选项编号（1/2/3/4/5，回车默认1）：
```

#### 情况B：输出目录为空
```
✅ 输出目录为空，将创建新的翻译文件结构...

📁 准备创建目录：
   ├── Languages/ChineseSimplified/Keyed/
   └── Languages/ChineseSimplified/DefInjected/

🚀 按回车继续，或输入 'b' 返回主菜单：
```

### **第四步：文件组织方式**（根据数据来源智能确定）

#### 情况A：使用 DefInjected 目录提取
```
📂 文件组织方式：
   └── 将按英文翻译文件的现有结构组织中文翻译文件
   └── 保持与原始模组相同的目录结构和文件名

✅ 配置完成，准备开始提取...

📊 预估工作量：
   ├── Keyed 翻译: ~541 条 (预计 30 秒)
   ├── DefInjected 翻译: ~2198 条 (预计 2 分钟)
   └── 总计: ~2739 条翻译内容

🚀 开始提取翻译内容...
```

#### 情况B：扫描 Defs 文件提取
```
请选择文件组织方式：

1. 📋 按定义类型分组（推荐）
   └── ThingDefs、PawnKindDefs、JobDefs 等
   └── 便于翻译工作分类管理
   
2. 📁 按源文件路径组织
   └── 保持与 Defs 目录相同的结构
   └── 便于对照原始定义文件
   
3. 🚫 返回主菜单

请输入选项编号（1/2/3，回车默认1）：
```

## 🛠️ **技术实现要点**

### 1. 状态检测函数
```python
def detect_extraction_environment(mod_dir: str, output_dir: str) -> dict:
    """全面检测提取环境状态"""
    return {
        'english_definjected': {
            'exists': bool,
            'path': str,
            'file_count': int,
            'size_mb': float
        },
        'english_keyed': {
            'exists': bool,
            'path': str, 
            'file_count': int,
            'size_mb': float
        },
        'output_definjected': {
            'exists': bool,
            'path': str,
            'file_count': int,
            'last_modified': datetime
        },
        'output_keyed': {
            'exists': bool,
            'path': str,
            'file_count': int, 
            'last_modified': datetime
        }
    }
```

### 2. 条件化流程控制
```python
def smart_extraction_workflow(mod_dir: str, output_dir: str) -> ExtractionConfig:
    """智能提取工作流"""
    # 第一步：状态检测
    env_status = detect_extraction_environment(mod_dir, output_dir)
    
    # 第二步：根据检测结果确定流程
    if env_status['english_definjected']['exists']:
        source_choice = prompt_data_source_choice(env_status)
    else:
        source_choice = 'defs'  # 自动选择
        
    # 第三步：冲突处理
    if has_existing_translations(env_status):
        conflict_resolution = prompt_conflict_resolution(env_status)
    else:
        conflict_resolution = 'create_new'
        
    # 第四步：组织方式
    if source_choice == 'definjected':
        organization = 'preserve_structure'  # 自动确定
    else:
        organization = prompt_organization_choice()
        
    return ExtractionConfig(
        source=source_choice,
        conflict_resolution=conflict_resolution,
        organization=organization
    )
```

### 3. 进度和状态反馈
```python
class ExtractionProgress:
    """提取进度管理"""
    
    def __init__(self, total_estimated: int):
        self.total_estimated = total_estimated
        self.current = 0
        
    def show_status_detection(self):
        """显示状态检测进度"""
        
    def show_extraction_progress(self, current: int, current_file: str):
        """显示提取进度"""
        
    def show_completion_summary(self, results: ExtractionResults):
        """显示完成总结"""
```

## 📝 **实现任务清单**

### Phase 1: 核心检测功能
- [ ] 实现 `detect_extraction_environment()` 函数
- [ ] 添加路径检测和文件统计功能
- [ ] 实现状态显示界面

### Phase 2: 条件化用户界面
- [ ] 重写数据来源选择逻辑
- [ ] 实现冲突处理选择界面
- [ ] 添加文件组织方式选择

### Phase 3: 智能流程控制
- [ ] 实现 `smart_extraction_workflow()` 主控制器
- [ ] 添加自动决策逻辑
- [ ] 集成进度反馈系统

### Phase 4: 错误处理和用户体验
- [ ] 添加详细的错误提示
- [ ] 实现备份和回滚机制
- [ ] 优化成功反馈界面

### Phase 5: 集成测试
- [ ] 测试各种环境组合
- [ ] 验证流程逻辑正确性
- [ ] 用户体验测试和优化

## 🎯 **预期效果**

### 用户体验改进
1. **清晰的状态认知**：用户一开始就知道当前环境状态
2. **减少决策负担**：只在必要时询问，提供明确建议
3. **智能默认选择**：根据环境状态提供合理的默认选项
4. **完整的反馈循环**：从检测到完成的全程状态反馈

### 技术质量提升
1. **减少用户错误**：通过检测和验证避免常见错误
2. **提高成功率**：智能处理各种边界情况
3. **更好的可维护性**：清晰的流程分离和模块化设计
4. **完善的错误处理**：预防和处理各种异常情况

## 📋 **后续优化方向**

1. **添加配置保存**：记住用户的常用选择
2. **批量处理支持**：支持多个模组的批量提取
3. **增量更新**：智能检测变化，只处理更新的内容
4. **自定义过滤**：允许用户自定义提取规则和过滤条件

---

**创建时间**: 2025-06-27  
**状态**: 设计完成，待实现  
**优先级**: 高（用户体验核心改进）
